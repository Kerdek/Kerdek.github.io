import { empty_inequalities } from './constraints.js';
import { typ_ref, typ_bol, typ_cnj, typ_dsj, typ_abs, typ_iov, typ_num, typ_str, typ_unk, typ_ext } from './graph.js';
const typ_unary_num_num = typ_abs([], typ_num(), typ_num());
const typ_binary_num_num_num = typ_abs([], typ_num(), typ_unary_num_num);
const typ_comparison = typ_cnj(typ_abs([], typ_str(), typ_abs([], typ_str(), typ_bol())), typ_abs([], typ_num(), typ_abs([], typ_num(), typ_bol())));
const typ_equality = typ_abs([], typ_unk(), typ_abs([], typ_unk(), typ_bol()));
export const builtins_types = {
    __builtin_return: (_call, ret) => () => ret([typ_abs([["x", false]], typ_ref("x"), typ_iov(typ_ref("x"))), empty_inequalities()]),
    __builtin_bind: (_call, ret) => () => ret([typ_abs([["x", false]], typ_iov(typ_ref("x")), typ_abs([["y", false]], typ_abs([], typ_ref("x"), typ_iov(typ_ref("y"))), typ_iov(typ_ref("y")))), empty_inequalities()]),
    __builtin_yield: (_call, ret) => () => ret([typ_iov(typ_unk()), empty_inequalities()]),
    __builtin_puts: (_call, ret) => () => ret([typ_abs([], typ_str(), typ_iov(typ_unk())), empty_inequalities()]),
    __builtin_new: (_call, ret) => () => ret([typ_abs([["x", false]], typ_ref("x"), typ_iov(typ_ext(typ_ref("x")))), empty_inequalities()]),
    __builtin_get: (_call, ret) => () => ret([typ_abs([["x", false]], typ_ext(typ_ref("x")), typ_iov(typ_ref("x"))), empty_inequalities()]),
    __builtin_set: (_call, ret) => () => ret([typ_abs([], typ_str(), typ_iov(typ_unk())), empty_inequalities()]),
    __builtin_if: (_call, ret) => () => ret([typ_abs([], typ_bol(), typ_abs([["x", false]], typ_ref("x"), typ_abs([["y", true]], typ_ref("y"), typ_dsj(typ_ref("x"), typ_ref("y"))))), empty_inequalities()]),
    __builtin_and: (_call, ret) => () => ret([typ_abs([["x", false]], typ_ref("x"), typ_abs([], typ_ref("x"), typ_ref("x"))), empty_inequalities()]),
    __builtin_or: (_call, ret) => () => ret([typ_abs([["x", false]], typ_ref("x"), typ_abs([], typ_ref("x"), typ_ref("x"))), empty_inequalities()]),
    __builtin_typeof: (_call, ret) => () => ret([typ_abs([["x", false]], typ_ref("x"), typ_str()), empty_inequalities()]),
    __builtin_slice: (_call, ret) => () => ret([typ_abs([], typ_str(), typ_abs([], typ_num(), typ_abs([], typ_num(), typ_str()))), empty_inequalities()]),
    __builtin_length: (_call, ret) => () => ret([typ_abs([], typ_str(), typ_num()), empty_inequalities()]),
    __builtin_neg: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_not: (_call, ret) => () => ret([typ_abs([], typ_unk(), typ_bol()), empty_inequalities()]),
    __builtin_cpl: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_mul: (_call, ret) => () => ret([typ_binary_num_num_num, empty_inequalities()]),
    __builtin_div: (_call, ret) => () => ret([typ_binary_num_num_num, empty_inequalities()]),
    __builtin_mod: (_call, ret) => () => ret([typ_binary_num_num_num, empty_inequalities()]),
    __builtin_add: (_call, ret) => () => ret([typ_cnj(typ_binary_num_num_num, typ_abs([], typ_str(), typ_abs([], typ_str(), typ_str()))), empty_inequalities()]),
    __builtin_sub: (_call, ret) => () => ret([typ_binary_num_num_num, empty_inequalities()]),
    __builtin_shl: (_call, ret) => () => ret([typ_binary_num_num_num, empty_inequalities()]),
    __builtin_shr: (_call, ret) => () => ret([typ_binary_num_num_num, empty_inequalities()]),
    __builtin_eq: (_call, ret) => () => ret([typ_equality, empty_inequalities()]),
    __builtin_neq: (_call, ret) => () => ret([typ_equality, empty_inequalities()]),
    __builtin_gt: (_call, ret) => () => ret([typ_comparison, empty_inequalities()]),
    __builtin_ge: (_call, ret) => () => ret([typ_comparison, empty_inequalities()]),
    __builtin_lt: (_call, ret) => () => ret([typ_comparison, empty_inequalities()]),
    __builtin_le: (_call, ret) => () => ret([typ_comparison, empty_inequalities()]),
    __builtin_bcj: (_call, ret) => () => ret([typ_binary_num_num_num, empty_inequalities()]),
    __builtin_bxj: (_call, ret) => () => ret([typ_binary_num_num_num, empty_inequalities()]),
    __builtin_bdj: (_call, ret) => () => ret([typ_binary_num_num_num, empty_inequalities()]),
    __builtin_floor: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_ceil: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_pi: (_call, ret) => () => ret([typ_num(), empty_inequalities()]),
    __builtin_sqrt: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_log: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_pow: (_call, ret) => () => ret([typ_binary_num_num_num, empty_inequalities()]),
    __builtin_exp: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_cos: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_sin: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_tan: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_acos: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_asin: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_atan: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_atan2: (_call, ret) => () => ret([typ_binary_num_num_num, empty_inequalities()]),
    __builtin_cosh: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_sinh: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_tanh: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_acosh: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_asinh: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_atanh: (_call, ret) => () => ret([typ_unary_num_num, empty_inequalities()]),
    __builtin_stringify: (_call, ret) => () => ret([typ_abs([], typ_dsj(typ_dsj(typ_str(), typ_num()), typ_bol()), typ_str()), empty_inequalities()])
};
//# sourceMappingURL=builtin_types.js.map